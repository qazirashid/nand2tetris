* Writing Assembler
  The assembler translates hack assembly code into hack machine code.
3 types of commands are understood by assembler.
** A_COMMAND
A_COMMANDS start with '@' and cause register A to load.  They can contains numbers in decimal e.g. @2342 or symbols e.g. @TheSymbol.
Where TheSymbol can be declared using an L_COMMAND or can be a variable name.

** L_COMMAND
It declares a symbol. It does not translate into a CPU instruction but is used only to inform assembler to remember the address of the next instruction because some A_INSTRUCTION will use this
symbol to refer to the address.
L_COMMAND must have the syntax  ' (Labelthis)' follwed by a new line.

** C_COMMAND
It is a command that causes ALU and control flow operations. It must use standard mnemonics e.g. ' A=A+D' and 'D;JNE'  and must not contain symbols.



In the first stage I built an assembler that took in a asm program with no symbols and translated it into machine code.
This was a rather simple program that did the lexical analysis, parsed strings and used a look up table to generate machine code.

In the second stage I built the assembler that accepted asm programs containing symbols. 3 types of hack assembly symbols are understood by assembler

** Predefined Symbols
These are symbols that refer to RAM address or registers like R0,.. R15, SP, LCL, etc.
They are loaded into symbol table at the very begining because assembler knows that these symbols are predefined. 

** Lables
These are labels that are used to tag assembly instructions for reference in other location. They are associated with the ROM address of instruction that is tagged.
We count the A_COMMANDS and C_COMMANDS to determine the ROM address 

These are loaded in the symbol table in PASS 1 of assembler when assembler is building symbol table. The assembler looks for L_COMMAND in PASS 1 and puts all symbols into 
symbol table and also stores the ROM addresses to which the symbols are referring.


** Variables
Any symbols found in the program that are not predefined and are not labels are treated as variables. They are assigned RAM addresses starting at location 16.
These are found in PASS2 with A_COMMANDS containing a symbol. If such a command is found, the assembler checks the symbol table
to determine if the symbol has been defined in PASS 1. If symbol is found in the symbol table, the assembler gets its address and generates the machine code.
If symbol is not found in the symbol table (hence they were not declared in the program using an L_COMMAND) then it is considered a variable and it is assigned a RAM address and then stored into symbol table to remember its RAM address
in case it is referred later on.

 

Both assemblers were tested on the provided 4 hack assembly programs and their output machine code was compared to the machine code generated by the given assembler. 
All tests were successfull. In total 8 programs in machine code were generated.

Then I used the HardwareSimulator and loaded my CPU into it. I loaded the ROM of CPU with the machine code that was generated by the assemblers and ran it on the CPU.
The CPU correctly ran all 8 programs.

This gives the indication that CPU and assemblers are working as expected and there are no known bugs.



 
